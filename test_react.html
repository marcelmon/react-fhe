<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Hello World</title>
    <script src="https://unpkg.com/react@16/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/babel-standalone@6.15.0/babel.min.js"></script>
  </head>
  <body>
    <div id="root"></div>
    <script type="text/babel">

      
// // acts as a data cache
//     // the currently selected data will also be set in the state variable
//     //
//     // collectionDataCache = {
//     //  collectionId: {   if collectionId not in collectionDataCache then it has not yet been loaded
//     //  'keyCtext': {
//     //    keyId: {
//     //      bitId: citCtext,
//     //    },
//     //  },
//     //  'valueCtext': {
//     //    keyId: ctext,
//     //  },
//     // }
//     // stores all loaded collections and any loaded polynomial data, avoid re-fetching from server
// var collectionDataCache = {};

function fetch(dataType, ...params){

  var collectionId = null;
  var keyId = null;
  var keyBitId = null;
  var url = null;

  switch(dataType){
    case 'collection_info':
      collectionId = params[0];
      url = "test_get.php?data_type=collection_info";
      break;
    case 'key_bit_ctext':
      collectionId = params[0];
      keyId = params[1];
      keyBitId = params[2];
      url = "test_get.php?data_type=key_bit_ctext&collectionId="+collectionId+"&keyId="+keyId+"&keyBitId="+keyBitId;
      break;
    case 'value_ctext':
      collectionId = params[0];
      keyId = params[1];
      url = "test_get.php?data_type=value_ctext&collectionId="+collectionId+"&keyId="+keyId;
      break;
    default:
      throw new Error('Invalid request data type.');
  }

  // Return a new promise.
  return new Promise(function(resolve, reject) {
    // Do the usual XHR stuff
    var req = new XMLHttpRequest();
    req.open('GET', url);

    req.onload = function() {

      if (req.status == 200) {
        console.log("got response : " + req.response);
        resolve(req.response);
      }
      else {
        reject(Error(req.statusText));
      }
    };

    req.onerror = function() {
      reject(Error("Network Error"));
    };

    req.send();
  });
  

}













class Cache {
  
  constructor(){
    this.cache = {};
  }
  isDataCached(collectionId, keyId, bitId = null){

    if(!(collectionId in this.cache) || !(keyId in this.cache[collectionId])){
      return false;
    }
    if(bitId == null){
      if(!('valueCtext' in this.cache[collectionId][keyId])){
        return false;
      }
    }
    else if(!('keyCtext' in this.cache[collectionId][keyId]) || !(bitId in this.cache[collectionId][keyId]['keyCtext'])){
      return false;
    }
    return true;
  }

  putData(collectionId, keyId, ctextData, bitId = null){

    if(!(collectionId in this.cache)){
      this.cache[collectionId] = {};
    }
    if(!(keyId in this.cache[collectionId])){
      this.cache[collectionId][keyId] = {};
    }
    if(bitId != null){ // is a key

      if(!('keyCtext' in this.cache[collectionId][keyId])){
        this.cache[collectionId][keyId]['keyCtext'] = {};
      }
      this.cache[collectionId][keyId]['keyCtext'][bitId] = ctextData;
    }
    else{ // is a value
      this.cache[collectionId][keyId]['valueCtext'] = ctextData;
    }
  }

  getData(collectionId, keyId, bitId = null){
    if(!this.isDataCached(collectionId, keyId, bitId)){
      return false;
    }
    if(bitId == null){
      return this.cache[collectionId][keyId]['valueCtext'];
    }
    return this.cache[collectionId][keyId]['keyCtext'][bitId];
  }
}




class UpdatedApp extends React.Component {



  getNumKeysAndKeyBits(collectionId){
    var numKeys = null;
    var numKeyBits = null;
    for (var i = 0; i < this.state.allCollectionInfo.length; i++) {
      if(this.state.allCollectionInfo[i].id == collectionId){
        numKeys = this.state.allCollectionInfo[i].numKeys;
        numKeyBits = this.state.allCollectionInfo[i].numKeyBits;
        break;
      }
    }
    return [numKeys, numKeyBits];
  }


  // called when app first loaded and when refresh needed (either user update or manually selects refresh)
  fetchAllCollectionInfo(){
    
    var collectionPromise = fetch('collection_info');
    collectionPromise.then((collectionData) => {
      this.setState({allCollectionInfo: JSON.parse(collectionData)});
    }).catch(function(err){

    });
  }


  // Callback for when a collection is clicked in the CollectionViewer
  // KevValueSelector will render using the collectionId and allCollectionInfo.numKeys/numKeyBits
  collectionClicked(collectionId){
    if(this.state.clickedCollectionId == collectionId){
      // already clicked
      return false;
    }
    var numKeys, numKeyBits;
    [numKeys, numKeyBits] = this.getNumKeysAndKeyBits(collectionId);

    this.setState({

      clickedCollectionId: collectionId,
      clickedCollectionNumKeys: numKeys,
      clickedCollectionNumKeyBits: numKeyBits,
      selectedDataKeyId : null,
      selectedDataIsKey: null,
      selectedDataBitId: null,
      selectedCtextData : null
    
    });

    return true;
  }



  // checks wethere the key bit (bitId != null) or value is selected already
  isCollectionDataClicked(collectionId, keyId, bitId = null){

    if( this.state.clickedCollectionId != collectionId  || this.state.selectedDataKeyId != keyId){
      return false;
    }
    // is key data
    if(bitId != null){
      if(!this.state.selectedDataIsKey || this.state.selectedDataBitId != bitId){
        return false;
      }
    }
    else if(this.state.selectedDataIsKey){
      return false;
    }
    return true;
  }


  // called when the ctextData is loaded for the selected data in KevValueViewer
  setSelectedDataState(collectionId, keyId, bitId = null){

   
    var numKeys, numKeyBits;
    [numKeys, numKeyBits] = this.getNumKeysAndKeyBits(collectionId);
    

    var newState = {
      clickedCollectionId: collectionId,
      selectedDataKeyId : keyId,
      selectedDataIsKey : (bitId == null)?false:true,
      selectedDataBitId : bitId,
      clickedCollectionNumKeys : numKeys,
      clickedCollectionNumKeyBits : numKeyBits
    };

    var data = this.cache.getData(collectionId, keyId, bitId);
    newState.selectedCtextData = (data)?data:null;
    
    this.setState(newState);
  }

  // callback when a data selector is clicked in the KeyValueSelector
  // propagate the state to the KeyValueSelector which will use the selectedCollectionId and allCollectionInfo state
  collectionDataClicked(collectionId, keyId, bitId = null){
        
    if(this.isCollectionDataClicked(collectionId, keyId, bitId)){ // already clicked, nothing to do 
      return false;
    }
      
    if(!this.cache.isDataCached(collectionId, keyId, bitId)) {

      var dataType = (bitId == null)? 'value_ctext' : 'key_bit_ctext';
      var ctextDataPromise = fetch(dataType, collectionId, keyId, bitId);
      ctextDataPromise.then((ctextData) => {      

        this.cache.putData(collectionId, keyId, ctextData, bitId);
        this.setSelectedDataState(collectionId, keyId, bitId);
      }).catch((err) => {

      });
    }
    else{
      this.setSelectedDataState(collectionId, keyId, bitId);
    }   
  }


  constructor(props){
    super(props);

    this.state = {

      allCollectionInfo: null,  // Holds colloquial name and num keys (see fetchAllCollectionInfo() for format)

      clickedCollectionId: null,
      clickedCollectionNumKeys: null,
      clickedCollectionNumKeyBits: null,
      
      selectedDataKeyId : null,
      selectedDataIsKey: null,
      selectedDataBitId: null,

      selectedCtextData : null
    };
    
    this.collectionClicked = this.collectionClicked.bind(this);
    this.collectionDataClicked = this.collectionDataClicked.bind(this);

    this.cache = new Cache();

    this.fetchAllCollectionInfo();

  }


  render(){

    return (
      <table><tbody><tr>
        <td>
          <CollectionViewer 
          collectionClicked={this.collectionClicked} 
          collectionsInfo={this.state.allCollectionInfo} 
          clickedCollectionId={this.state.clickedCollectionId} />
        </td>
        <td>
          <table><tbody>
            <tr><td>
              <KeyValueSelector 
              collectionDataClicked={this.collectionDataClicked}
              clickedCollectionId={this.state.clickedCollectionId} 
              clickedCollectionNumKeys={this.state.clickedCollectionNumKeys}
              clickedCollectionNumKeyBits={this.state.clickedCollectionNumKeyBits}/>
            </td></tr>
            <tr><td>
              <DataViewer 
              selectedDataKeyId = {this.state.selectedDataKeyId} 
              selectedCtextData={this.state.selectedCtextData} />
            </td></tr>
          </tbody></table>
        </td>
      </tr></tbody></table>
    );
  }
}




class CollectionViewer extends React.Component {


  componentWillReceiveProps(nextProps){
    this.setState(nextProps);
  }


  constructor(props){
    super(props);
    
    this.state = {
      collectionsInfo: props.collectionsInfo,
      clickedCollectionId: props.clickedCollectionId
    };
    this.collectionClicked = props.collectionClicked;
  }

  render(){
    if(!this.state.collectionsInfo){
      return(<div>Loading collections.</div>);
    }
    
    return(
      <table><tbody>
      {
        this.state.collectionsInfo.map((info) => { return( 
          <tr><td>
            <div collectionid={info.id} onClick={() => this.collectionClicked(info.id)}>
              Collection: {info.colloquialName}
            </div>
          </td></tr>
        )})
      }
      </tbody></table>
    );
  }
}


class KeyValueSelector extends React.Component {

  componentWillReceiveProps(nextProps){
    this.setState(nextProps);
  }

  constructor(props){
    super(props);

    this.state = {
      clickedCollectionId: props.clickedCollectionId,
      clickedCollectionNumKeys : props.clickedCollectionNumKeys,
      clickedCollectionNumKeyBits: props.clickedCollectionNumKeyBits
    };
    // these are the callback functions for when a selector is clicked
    this.collectionDataClicked = props.collectionDataClicked;

  }

  render(){

    if(!this.state.clickedCollectionId){
      return(<div>Select a collection.</div>);
    }
    // have a selected: collectionId, numKeys, numBits

    var keyIds = new Array(this.state.clickedCollectionNumKeys);
    for (var i = 0; i < keyIds.length; i++) {
      keyIds[i] = i+1;
    };
    var keyBitIds = new Array(this.state.clickedCollectionNumKeyBits);
    for (var i = 0; i < keyBitIds.length; i++) {
      keyBitIds[i] = i+1;
    };
   
    return(
      <div>
      { 
        keyIds.map((keyId) => { return(
          <table><tbody><tr>
            <td>
              <div onClick={() => this.collectionDataClicked(this.state.clickedCollectionId, keyId, null)}>
                Key: {keyId}
              </div>
            </td>
            <td>
              <table><tbody><tr>
              { 
                keyBitIds.map((bitId) => { return(
                  <td onClick={() => this.collectionDataClicked(this.state.clickedCollectionId, keyId, bitId)}>
                      Bit: {bitId}
                  </td>
                )})
              }
              </tr></tbody></table>
            </td>
          </tr></tbody></table>
        )})
      }
      </div>
    );
  }
}




 /* 
        the selectedData is a lattice as multi dimensional array.
        [
          [[---],[---]],
          [[---],[---]],
          [[---],[---]]
        ]

        Display as: 
          -|-|-   -|-|-
          -|-|- -|-|-
          -|-|- -|-|- 

        <table>
          <tr>
            <td>Element 1,1,1 | Element 1,1,2 | Element 1,1,3</td><td>Element 1,2,1 | Element 1,2,2 | Element 1,2,3</td>
          </tr>
          <tr>
            <td>Element 2,1,1 | Element 2,1,2 | Element 2,1,3</td><td>Element 2,2,1 | Element 2,2,2 | Element 2,2,3</td>
          </tr>
          <tr>
            <td>Element 3,1,1 | Element 3,1,2 | Element 3,1,3</td><td>Element 3,2,1 | Element 3,2,2 | Element 3,2,3</td>
          </tr>
        </table>
      */
class DataViewer extends React.Component {


  componentWillReceiveProps(nextProps){
    this.setState(nextProps);
  }

  constructor(props){
    super(props);
    this.state = {
      selectedDataKeyId: props.selectedDataKeyId,
      selectedCtextData: props.selectedCtextData
    }
      
  }

  render(){
    if(!this.state.selectedDataKeyId){
      return(<div>Select either key or value to load and view data</div>);
    }
    else if(this.state.selectedCtextData == null){
      return(<div>Loading data...</div>);
    }
    else{
      var data = this.state.selectedCtextData;
      if(typeof this.state.selectedCtextData != typeof {}){
        data = (JSON.parse(data));
      }
    
      return(
        <table><tbody>
        {
          data.map((arrayOfPolynomials) => { return(
            <tr> 
            {
              arrayOfPolynomials.map((polyArray) => { return(
                <td> {polyArray.join(" | ")} </td>
              )})
            }
            </tr>
          )})
        }
        </tbody></table>
      );
    }
  }

}


ReactDOM.render(
        <UpdatedApp/>,
        document.getElementById('root')
      );


    </script>
    <!--
      Note: this page is a great way to try React but it's not suitable for production.
      It slowly compiles JSX with Babel in the browser and uses a large development build of React.

      To set up a production-ready React build environment, follow these instructions:
      * https://reactjs.org/docs/add-react-to-a-new-app.html
      * https://reactjs.org/docs/add-react-to-an-existing-app.html

      You can also use React without JSX, in which case you can remove Babel:
      * https://reactjs.org/docs/react-without-jsx.html
      * https://reactjs.org/docs/cdn-links.html
    -->
  </body>
</html>
