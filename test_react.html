<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Hello World</title>
    <script src="https://unpkg.com/react@16/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/babel-standalone@6.15.0/babel.min.js"></script>
  </head>
  <body>
    <div id="root"></div>
    <script type="text/babel">

      
// acts as a data cache
    // the currently selected data will also be set in the state variable
    //
    // collectionDataCache = {
    //  collectionId: {   if collectionId not in collectionDataCache then it has not yet been loaded
    //  'keyCtext': {
    //    keyId: {
    //      bitId: citCtext,
    //    },
    //  },
    //  'valueCtext': {
    //    keyId: ctext,
    //  },
    // }
    // stores all loaded collections and any loaded polynomial data, avoid re-fetching from server
var collectionDataCache = {};

function fetch(dataType, ...params){

  var collectionId = null;
  var keyId = null;
  var keyBitId = null;
  var url = null;

  switch(dataType){
    case 'collection_info':
      collectionId = params[0];
      url = "test_get.php?data_type=collection_info";
      break;
    case 'key_bit_ctext':
      collectionId = params[0];
      keyId = params[1];
      keyBitId = params[2];
      url = "test_get.php?data_type=key_bit_ctext&collectionId="+collectionId+"&keyId="+keyId+"&keyBitId="+keyBitId;
      break;
    case 'value_ctext':
      collectionId = params[0];
      keyId = params[1];
      url = "test_get.php?data_type=value_ctext&collectionId="+collectionId+"&keyId="+keyId
      break;
    default:
      throw new Error('Invalid request data type.');
  }

  // Return a new promise.
  return new Promise(function(resolve, reject) {
    // Do the usual XHR stuff
    var req = new XMLHttpRequest();
    req.open('GET', url);

    req.onload = function() {

      if (req.status == 200) {
        console.log("got response : " + req.response);
        resolve(req.response);
      }
      else {
        reject(Error(req.statusText));
      }
    };

    req.onerror = function() {
      reject(Error("Network Error"));
    };

    req.send();
  });
  

}





















class UpdatedApp extends React.Component {

  // default state

  /*
    {
      allCollectionInfo: null,  Holds colloquial name and num keys (see fetchAllCollectionInfo() for format)
      clickedCollectionId: null,
      clickedCollectionNumKeys: null,
      clickedCollectionNumKeyBits: null,
      
      selectedDataKeyId : null,
      selectedDataIsKey: null,
      selectedDataBitId: null,

      selectedCtextData : null
    
    }



  */

  getNumKeysAndKeyBits(collectionId){
    var numKeys = null;
    var numKeyBits = null;
    for (var i = 0; i < this.state.allCollectionInfo.length; i++) {
      if(this.state.allCollectionInfo[i].id == collectionId){
        numKeys = this.state.allCollectionInfo[i].numKeys;
        numKeyBits = this.state.allCollectionInfo[i].numKeyBits;
        break;
      }
    }
    return [numKeys, numKeyBits];
  }


  // called when app first loaded and when refresh needed (either user update or manually selects refresh)
  fetchAllCollectionInfo(){
    /* loads 
    {
      collectionId_1: {
        numKeys:3,
        colloquial_name: "my collection"
      },
    }
    */
    
    var collectionPromise = fetch('collection_info');
    collectionPromise.then((collectionData) => {
      

      this.setState({allCollectionInfo: JSON.parse(collectionData)});

    }).catch(function(err){

    });

  }


  isCtextDataCached(collectionId, keyId, bitId = null){
    if( !(collectionId in this.collectionDataCache) || !(keyId in this.collectionDataCache[collectionId])){
      return false;
    }
    if(bitId == null && !('keyCtext' in this.collectionDataCache[collectionId][keyId])){
      return false;
    }
    else if(!('valueCtext' in this.collectionDataCache[collectionId][keyId]) || !(bitId in this.collectionDataCache[collectionId][keyId]['valueCtext'])) {
      return false;
    }
    return true;
  }

  cacheCtextData(collectionId, keyId, ctextData, bitId = null){

    console.log("3");
    if(!(collectionId in this.collectionDataCache)){
      this.collectionDataCache[collectionId] = {};
    }
    if(!(keyId in this.collectionDataCache[collectionId])){
      this.collectionDataCache[collectionId][keyId] = {};
    }
    if(bitId != null){ // is a key
      if(!('keyCtext' in this.collectionDataCache[collectionId][keyId])){
        this.collectionDataCache[collectionId][keyId]['keyCtext'] = {};
      }
      this.collectionDataCache[collectionId][keyId]['keyCtext'][bitId] = ctextData;
    }
    else{ // is a value
      this.collectionDataCache[collectionId][keyId]['valueCtext'] = ctextData;
    }
  }




  isCollectionClicked(collectionId){
    if(!this.state.clickedCollectionId != collectionId){
      return false;
    }
    return true;
  }

  // Callback for when a collection is clicked in the CollectionViewer
  // KevValueSelector will render using the collectionId and allCollectionInfo.numKeys/numKeyBits
  collectionClicked(collectionId){
    if(this.isCollectionClicked(collectionId)){
      // this collection is already clicked, do nothing
      return false;
    }
    var numKeys, numKeyBits;
    [numKeys, numKeyBits] = this.getNumKeysAndKeyBits(collectionId);

    console.log("COLLECTION CLICKED : " +collectionId);
    this.setState({

      clickedCollectionId: collectionId,

      clickedCollectionNumKeys: numKeys,
      clickedCollectionNumKeyBits: numKeyBits,
      
      selectedDataKeyId : null,
      selectedDataIsKey: null,
      selectedDataBitId: null,

      selectedCtextData : null
    
    });
    return true;
  }



  // checks wethere the key bit (bitId != null) or value is selected already
  isCollectionDataClicked(collectionId, keyId, bitId = null){

    if( this.state.clickedCollectionId != collectionId  || this.state.selectedDataKeyId != keyId){
      return false;
    }
    // is key data
    if(bitId != null && (!this.state.selectedDataIsKey || this.state.selectedDataBitId != bitId) ){
      return false;
    }
    else if(bitId == null && this.state.selectedDataIsKey){
      return false;
    }
    return true;
  }


  // called when the ctextData is loaded for the selected data in KevValueViewer
  setSelectedDataState(collectionId, keyId, bitId = null){

    
    var numKeys, numKeyBits;
    [numKeys, numKeyBits] = this.getNumKeysAndKeyBits(collectionId);

    var newState = {
      clickedCollectionId: collectionId,
      clickedCollectionNumKeys: numKeys,
      clickedCollectionNumKeyBits: numKeyBits,

      selectedDataKeyId : keyId,

      selectedDataIsKey: null,
      selectedDataBitId: null,
      selectedCtextData: null,
    };

    // is a value
    if(bitId == null){
      newState.selectedDataIsKey = false;
      newState.selectedDataBitId = null;
      newState.selectedCtextData = this.collectionDataCache[collectionId][keyId]['valueCtext'];
    }
    else{
      // is a key
      newState.selectedDataIsKey = true;
      newState.selectedDataBitId = bitId;
      newState.selectedCtextData = this.collectionDataCache[collectionId][keyId]['keyCtext'][bitId];
    }
    this.setState(newState);
  }

  // callback when a data selector is clicked in the KeyValueSelector
  // propagate the state to the KeyValueSelector which will use the selectedCollectionId and allCollectionInfo state
  collectionDataClicked(collectionId, keyId, bitId = null){
      

    if(this.isCollectionDataClicked(collectionId, keyId, bitId)){ // this 
      return false;
    }
    // check if the ctext data was already loaded otherwise fetch the ctext data
    
    if(!this.isCtextDataCached(collectionId, keyId, bitId)) {

      var dataType = (bitId == null)? 'value_ctext' : 'key_bit_ctext';
      var ctextDataPromise = fetch(dataType, collectionId, keyId, bitId);
      ctextDataPromise.then((ctextData) => {
  

        // console.log("ctext data : " + JSON.stringify(ctextData) + "///////"+ JSON.stringify([dataType, collectionId, keyId, bitId]));

        console.log("in 1");       

        this.cacheCtextData(collectionId, keyId, ctextData, bitId);

        console.log("in 2");
        this.setSelectedDataState(collectionId, keyId, bitId);
         console.log("in 4");
      }).catch((err) => {

      });
    }
    else{
      this.setSelectedDataState(collectionId, keyId, bitId);
    }   
  }


  constructor(props){
    super(props);

    

    this.nums = 0;

    this.state = {

      
      allCollectionInfo: null,  // Holds colloquial name and num keys (see fetchAllCollectionInfo() for format)

      clickedCollectionId: null,
      clickedCollectionNumKeys: null,
      clickedCollectionNumKeyBits: null,
      
      selectedDataKeyId : null,
      selectedDataIsKey: null,
      selectedDataBitId: null,

      selectedCtextData : null
    
    
    };
    
    this.collectionDataCache = {};
    this.collectionClicked = this.collectionClicked.bind(this);
    this.collectionDataClicked = this.collectionDataClicked.bind(this);

    // this.cacheCtextData = this.cacheCtextData.bind(this);
    this.fetchAllCollectionInfo();
  }


  render(){
    console.log("app render"+(this.nums++)+JSON.stringify(this.state)+"DONEEEE app");

    console.log("app render c"+(this.nums)+JSON.stringify(this.state.allCollectionInfo)+"DONEEEE app c");


    return (
      <table><tbody>
        <tr><td>
          <CollectionViewer 
          collectionClicked={this.collectionClicked} 
          collectionsInfo={this.state.allCollectionInfo} 
          clickedCollectionId={this.state.clickedCollectionId} />
        </td>
        <td>
          <table><tbody>
            <tr><td>
              <KeyValueSelector 
              collectionDataClicked={this.collectionDataClicked}
              clickedCollectionId={this.state.clickedCollectionId} 
              clickedCollectionNumKeys={this.state.clickedCollectionNumKeys}
              clickedCollectionNumKeyBits={this.state.clickedCollectionNumKeyBits}/>
            </td></tr>
            <tr><td>
              <DataViewer 
              selectedDataKeyId = {this.state.selectedDataKeyId} 
              selectedCtextData={this.state.selectedCtextData} />
            </td></tr>
          </tbody></table>
        </td>
      </tr></tbody></table>
    );
  }
}




class CollectionViewer extends React.Component {


  componentWillReceiveProps(nextProps){
    this.setState(nextProps);
  }


  constructor(props){
    super(props);
    
    this.numm = 0;
    this.state = {
      collectionsInfo: props.collectionsInfo,
      clickedCollectionId: props.clickedCollectionId
    };
    this.collectionClicked = props.collectionClicked;
  }

  render(){
    console.log("collect viewr render"+(this.numm++)+JSON.stringify(this.state)+"DONEEEE collect");
    if(!this.state.collectionsInfo){
      return(<div>Loading collections.</div>);
    }
    return(
      <table><tbody>
        {this.state.collectionsInfo.map((singleCollectionInfo) => {
          return( 
            <tr><td>
              <div collectionid={singleCollectionInfo.id} onClick={() => this.collectionClicked(singleCollectionInfo.id)}>
                Collection: {singleCollectionInfo.colloquialName}
              </div>
            </td></tr>
          );
        })}
      </tbody></table>
    );
  }
}


class KeyValueSelector extends React.Component {

  componentWillReceiveProps(nextProps){

    console.log("kv prev " + JSON.stringify(this.state));
    console.log("kv next " + JSON.stringify(nextProps));
    this.setState(nextProps);
  }

  constructor(props){
    super(props);

    this.state = {
      clickedCollectionId: props.clickedCollectionId,
      clickedCollectionNumKeys : props.clickedCollectionNumKeys,
      clickedCollectionNumKeyBits: props.clickedCollectionNumKeyBits
    };
    // these are the callback functions for when a selector is clicked
    this.collectionDataClicked = props.collectionDataClicked;

    this.nummm = 0;
  }



  keyBit(collectionId, keyId, bitId){
    return(
      <td><div onClick={() => this.collectionDataClicked(collectionId, keyId, bitId)}>
          Bit: {bitId}
      </div></td>
    );
  }

  keyBits(collectionId, keyId, keyBitIds){
    return(
      <table><tbody>
      <tr>
      { 
        keyBitIds.map((bitId) => this.keyBit(collectionId, keyId, bitId))
      }
      </tr>
      </tbody></table>
    );
  }

  keyValueRow(collectionId, keyId, keyBitIds){
    return(
      <table><tbody>
        <tr>
          <td>
            <div onClick={() => this.collectionDataClicked(collectionId, keyId, null)}>
              Key: {keyId}
            </div>
          </td>
          <td>
            { this.keyBits(collectionId, keyId, keyBitIds) }
          </td>
        </tr>
        </tbody></table>
    );
  }


  render(){

    console.log("Render kv " + JSON.stringify(this.state)+(this.nummm++)+"done");
    // have a selected: collectionId, numKeys, numBits

    var keyIds = new Array(this.state.clickedCollectionNumKeys);
    for (var i = 0; i < keyIds.length; i++) {
      keyIds[i] = i+1;
    };
    var keyBitIds = new Array(this.state.clickedCollectionNumKeyBits);
    for (var i = 0; i < keyBitIds.length; i++) {
      keyBitIds[i] = i+1;
    };
   
    if(!this.state.clickedCollectionId){
      return(<div>Select a collection.</div>);
    }
    console.log("KEYIDS ! " + keyIds);


    

    return(
      <div>
      { 
        keyIds.map((keyId) => { return(
          <table><tbody>
          <tr>
          {this.keyValueRow(this.state.clickedCollectionId, keyId, keyBitIds)}
          </tr>
          </tbody></table>
          )})
      }
      </div>
    );
  }
}




class DataViewer extends React.Component {


  componentWillReceiveProps(nextProps){

    console.log("DataViewer prev " + JSON.stringify(this.state));
    console.log("DataViewer new " + JSON.stringify(nextProps));
    this.setState(nextProps);
    console.log("DataViewer fina " + JSON.stringify(this.state));
    console.log(typeof this.state.selectedCtextData);
  }

  constructor(props){
    super(props);
    this.state = {
      selectedDataKeyId: props.selectedDataKeyId,
      selectedCtextData: props.selectedCtextData


    }
      
  }


  // param arrayOfPolynomials is multi dimensional array
  // first level is array of polyArray
  // generates a table row with each polynomail
  // <tr> <td> 1111 | 1112 | 1113 </td> <td> 2221 | 2222 | 2223 </td> </tr>
  buildPolyTableRow(arrayOfPolynomials){
    return(<tr> {arrayOfPolynomials.map((polyArray) => this.buildPolyTableCell(polyArray))} </tr>);
  }

  // param polyArray is array of ints representing all coefficients of a single polynomial
  // generates a table cell <td> 1234 | 1341 | 3521 </td> 
  buildPolyTableCell(polyArray){
    return(<td> {polyArray.join(" | ")} </td>);
  }

  render(){
    if(!this.state.selectedDataKeyId){
      return(<div>Select either key or value to load and view data</div>);
    }
    else if(this.state.selectedCtextData == null){
      return(<div>Loading data...</div>);
    }
    else{
      console.log("THE selectedCtextData:: ");
      console.log(this.state.selectedCtextData);
      console.log("THE SELECTESTEXDATA FINISH");
      /* 
        the selectedData is a lattice as multi dimensional array.
        [
          [[---],[---]],
          [[---],[---]],
          [[---],[---]]
        ]

        Display as: 
          -|-|-   -|-|-
          -|-|- -|-|-
          -|-|- -|-|- 

        <table>
          <tr>
            <td>Element 1,1,1 | Element 1,1,2 | Element 1,1,3</td><td>Element 1,2,1 | Element 1,2,2 | Element 1,2,3</td>
          </tr>
          <tr>
            <td>Element 2,1,1 | Element 2,1,2 | Element 2,1,3</td><td>Element 2,2,1 | Element 2,2,2 | Element 2,2,3</td>
          </tr>
          <tr>
            <td>Element 3,1,1 | Element 3,1,2 | Element 3,1,3</td><td>Element 3,2,1 | Element 3,2,2 | Element 3,2,3</td>
          </tr>
        </table>
      */

      console.log("RENDERING");
      return(
        <table><tbody>
        {
          (JSON.parse(this.state.selectedCtextData)).map((arrayOfPolynomials) => this.buildPolyTableRow(arrayOfPolynomials))
        }</tbody></table>
      );
    }
  }

}


ReactDOM.render(
        <UpdatedApp/>,
        document.getElementById('root')
      );


    </script>
    <!--
      Note: this page is a great way to try React but it's not suitable for production.
      It slowly compiles JSX with Babel in the browser and uses a large development build of React.

      To set up a production-ready React build environment, follow these instructions:
      * https://reactjs.org/docs/add-react-to-a-new-app.html
      * https://reactjs.org/docs/add-react-to-an-existing-app.html

      You can also use React without JSX, in which case you can remove Babel:
      * https://reactjs.org/docs/react-without-jsx.html
      * https://reactjs.org/docs/cdn-links.html
    -->
  </body>
</html>
